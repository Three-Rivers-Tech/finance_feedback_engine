from abc import ABC, abstractmethod
from typing import Dict, Any, List, Optional
import pandas as pd
import logging

logger = logging.getLogger(__name__)

class BaseAIModel(ABC):
    """
    Abstract Base Class (ABC) for AI models used in the Finance Feedback Engine.

    This ABC defines a standard interface that all AI models must implement, 
    promoting modularity, interchangeability, and adherence to best practices
    in financial AI, especially regarding explainability (XAI) and metadata.

    Implementation Notes:
    - **Standardized Interface:** Ensures consistency across different AI models
      (local, CLI-based, cloud APIs) used by the decision engine.
    - **Explainability (XAI):** The `explain` method is crucial for financial
      applications, addressing regulatory compliance and building trust by
      providing insights into model decisions.
    - **Metadata & Reproducibility:** `get_metadata` ensures that key information
      about the model (version, training data, parameters) is always available,
      which is vital for auditability and reproducibility.
    - **Data Input/Output Contract:** Specifies that models should operate on
      pandas DataFrames for input features and return a structured dictionary
      for decisions, making integration with the rest of the system seamless.

    TODO:
    - **Error Handling:** Define specific custom exceptions for model-related
      errors (e.g., `ModelPredictionError`, `ModelExplanationError`).
    - **Asynchronous Methods:** Consider `async` versions of `predict` and `explain`
      if model inference can be non-blocking (e.g., for external API calls).
    - **Batch Prediction:** Add a `predict_batch` method for optimizing inference
      on multiple data points.
    - **Input Feature Validation:** Integrate a mechanism to validate input features
      (e.g., schema, range checks) before passing them to the model.
    - **Model Loading/Saving:** Define abstract methods for loading and saving
      model weights/artifacts in a standardized format.
    - **Pre-processing/Post-processing:** Explicitly define where data
      pre-processing and post-processing steps should occur, perhaps
      as part of the `predict` method or in separate helper methods.
    """

    def __init__(self, config: Dict[str, Any]):
        self.config = config
        self.model_name = config.get("model_name", self.__class__.__name__)
        self.version = config.get("version", "1.0.0") # TODO: Auto-detect or load from model artifact

    @abstractmethod
    def predict(self, features: pd.DataFrame) -> Dict[str, Any]:
        """
        Generates a trading decision based on input features.

        Args:
            features (pd.DataFrame): A DataFrame containing the input features
                                     required for the model to make a prediction.
                                     Expected columns and format should be documented
                                     by concrete implementations.

        Returns:
            Dict[str, Any]: A dictionary containing the trading decision,
                            e.g., {'action': 'BUY'/'SELL'/'HOLD', 'confidence': 0.85, 'reasoning': '...'}.
        TODO:
        - Define a more strict Pydantic model or dataclass for the return type
          to ensure consistency across all AI models.
        - Include latency metrics in the return.
        """
        pass

    @abstractmethod
    def explain(self, features: pd.DataFrame, decision: Dict[str, Any]) -> Dict[str, Any]:
        """
        Provides an explanation for a generated trading decision.

        This method should leverage Explainable AI (XAI) techniques to
        give insights into why the model made a particular decision.

        Args:
            features (pd.DataFrame): The input features used for the decision.
            decision (Dict[str, Any]): The trading decision generated by the model.

        Returns:
            Dict[str, Any]: A dictionary containing the explanation, 
                            e.g., {'key_factors': ['RSI overbought', 'bearish MACD'],
                                  'feature_contributions': {'feature_X': 0.1, 'feature_Y': -0.05}}.

        TODO:
        - Integrate specific XAI libraries (e.g., SHAP, LIME) within concrete
          implementations to generate explanations.
        - Define a standard format for explanations to facilitate downstream
          processing and display.
        - Handle cases where explanations might not be available or are limited
          for certain model types.
        """
        pass

    def get_metadata(self) -> Dict[str, Any]:
        """
        Returns metadata about the AI model.

        This is crucial for auditing, reproducibility, and model governance.

        Returns:
            Dict[str, Any]: A dictionary containing model metadata, e.g.:
                            {'model_name': 'MyAwesomeModel',
                             'version': '1.0.0',
                             'training_data_source': '...',
                             'training_date': '...',
                             'parameters': {'hyperparam_X': val, 'hyperparam_Y': val},
                             'expected_features': ['feature_1', 'feature_2'],
                             'output_schema': {'action': 'str', 'confidence': 'float'}}.
        """
        # Default implementation, should be extended by concrete classes
        return {
            "model_name": self.model_name,
            "version": self.version,
            "description": "Base AI Model for financial trading decisions.",
            "type": "abstract",
            "capabilities": ["prediction", "explanation"],
            # TODO: Add more specific metadata like training data, last updated, etc.
        }

class DummyAIModel(BaseAIModel):
    """
    A dummy implementation of BaseAIModel for testing and demonstration purposes.
    """
    def __init__(self, config: Dict[str, Any]):
        super().__init__(config)
        logger.info(f"Initialized DummyAIModel: {self.model_name} (version: {self.version})")

    def predict(self, features: pd.DataFrame) -> Dict[str, Any]:
        """
        Generates a random BUY/SELL/HOLD decision with random confidence.
        """
        # TODO: Implement more sophisticated dummy logic based on features
        if features.empty:
            return {"action": "HOLD", "confidence": 0.5, "reasoning": "No features provided."}
        
        actions = ["BUY", "SELL", "HOLD"]
        import random
        action = random.choice(actions)
        confidence = round(random.uniform(0.5, 0.95), 2)
        reasoning = f"Dummy model recommends {action} with {confidence*100}% confidence based on arbitrary logic."
        
        logger.info(f"DummyAIModel predicted: {action} with {confidence*100}% confidence.")
        return {"action": action, "confidence": confidence, "reasoning": reasoning}

    def explain(self, features: pd.DataFrame, decision: Dict[str, Any]) -> Dict[str, Any]:
        """
        Provides a dummy explanation based on the decision.
        """
        # TODO: Implement a simple, feature-based dummy explanation.
        # e.g., if action is BUY, mention last_close price was high.
        explanation = {
            "key_factors": ["Randomness", "Simplicity"],
            "feature_contributions": {col: round(random.uniform(-0.1, 0.1), 3) for col in features.columns} if not features.empty else {},
            "model_specific_details": "This is a dummy explanation from a dummy model."
        }
        logger.info(f"DummyAIModel explained decision: {decision['action']}.")
        return explanation

# Example Usage (for demonstration within this stub)
if __name__ == "__main__":
    logging.basicConfig(level=logging.INFO)
    dummy_config = {"model_name": "TestDummy", "version": "0.0.1"}
    dummy_model = DummyAIModel(dummy_config)

    # Create dummy features
    test_features = pd.DataFrame({
        "RSI": [70.0],
        "MACD": [0.5],
        "Volume": [10000.0],
        "LastClose": [1000.0]
    })

    print("--- Dummy Model Prediction ---")
    decision = dummy_model.predict(test_features)
    print(f"Decision: {decision}")

    print("\n--- Dummy Model Explanation ---")
    explanation = dummy_model.explain(test_features, decision)
    print(f"Explanation: {explanation}")

    print("\n--- Dummy Model Metadata ---")
    metadata = dummy_model.get_metadata()
    print(f"Metadata: {metadata}")
